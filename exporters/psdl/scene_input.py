from re import T
import numpy as np
from common.scene_input import SceneInput
from common.file_io import BinaryFileHelper


class StandaloneSceneInput(SceneInput):
    def __init__(self, filepath):
        self.filepath = filepath
        self.obj_list = []
        self.read()

    def create_obj(self):
        obj = {}
        obj["name"] = ""
        obj["vertices"] = []
        obj["indices"] = []
        obj["normals"] = None
        obj["uvs"] = None
        obj["location"] = [0, 0, 0]
        obj["scale"] = [1, 1, 1]
        obj["rotation"] = [1, 0, 0, 0]
        obj["properties"] = {}
        return obj

    def read(self):
        file = BinaryFileHelper(self.filepath, 'rb')
        header = file.read_uint32()
        expected_header = int.from_bytes(b'km2B', 'little')
        if header != expected_header: raise Exception("not a .bin file generated by km2 City Builder")
        header2 = file.read_string()
        if header2 != "MidtownMadness2": raise Exception("not a .bin file generated by km2 City Builder with the Midtown Madness 2 core")
        num_elems = file.read_uint32()
        for i in range(num_elems):
            #read the data
            is_mesh = file.read_byte() > 0
            name = file.read_string()
            num_properties = file.read_uint32()
            raw_properties = list(file.read_string() for j in range(num_properties * 2))
            num_verts = file.read_uint32()
            verts = list(file.read_vec3() for j in range(num_verts))
            num_indices = file.read_uint32()
            if is_mesh:
                indices = []
                for j in range(num_indices):
                    num_sub_indices = file.read_uint32()
                    indices.append(list(file.read_uint16() for i in range(num_sub_indices)))
                normals = list(file.read_vec3() for j in range(num_verts))
                uvs = list(file.read_vec2() for j in range(num_verts))
            else:
                indices = list(file.read_uint16() for j in range(num_indices))
                normals = None
                uvs = None
            num_mats = file.read_uint32()
            materials = list(file.read_string() for j in range(num_mats))
            transformed = file.read_byte()
            if transformed > 0:
                pos = file.read_vec3()
                scale = file.read_vec3()
                rot = file.read_quaternion()
            
            #create the object
            obj = self.create_obj()
            obj["properties"]["is_mesh"] = is_mesh
            obj["name"] = name
            obj["vertices"] = verts
            obj["indices"] = indices
            obj["normals"] = normals
            obj["uvs"] = uvs
            for j in range(num_mats):
                obj["properties"]["texture" + str(j)] = materials[j]
            if transformed > 0:
                obj["rotation"] = rot
                obj["scale"] = scale
                obj["location"] = pos
            for pi in  range(0, len(raw_properties), 2):
                p_key = raw_properties[pi]
                p_value = raw_properties[pi + 1]
                obj["properties"][p_key] = p_value
            self.obj_list.append(obj)
        self.obj_list = sorted(self.obj_list, key=lambda x: x['name'])
        print("BIN file imported!")
        file.close()

    def init_progress_bar(self):
        pass

    def set_progress_bar(self, value):
        pass

    def end_progress_bar(self):
        pass

    def get_object_list(self):
        return self.obj_list

    def get_object_name(self, obj):
        return obj["name"]

    def get_rotation(self, obj):
        q = obj["rotation"]
        rx = np.arctan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2]))
        ry = np.arcsin(2 * (q[0] * q[2] - q[3] * q[1]))
        rz = np.arctan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3]))
        return [rx, ry, rz]

    def get_property_container(self, obj):
        return obj["properties"]

    def get_vertices_num(self, obj):
        return len(obj["vertices"])

    def get_scale_matrix(self, v):
        return [[v[0], 0,    0,    0],
                [0,    v[1], 0,    0],
                [0,    0,    v[2], 0],
                [0,    0,    0,    1]]

    def get_translation_matrix(self, v):
        return [[1, 0, 0, v[0]],
                [0, 1, 0, v[1]],
                [0, 0, 1, v[2]],
                [0, 0, 0, 1   ]]

    def get_rotation_matrix(self, q):
        e00 = 2 * (q[0] * q[0] + q[1] * q[1]) - 1
        e01 = 2 * (q[1] * q[2] - q[0] * q[3])
        e02 = 2 * (q[1] * q[3] + q[0] * q[2])
        e10 = 2 * (q[1] * q[2] + q[0] * q[3])
        e11 = 2 * (q[0] * q[0] + q[2] * q[2]) - 1
        e12 = 2 * (q[2] * q[3] - q[0] * q[1])
        e20 = 2 * (q[1] * q[3] - q[0] * q[2])
        e21 = 2 * (q[2] * q[3] + q[0] * q[1])
        e22 = 2 * (q[0] * q[0] + q[3] * q[3]) - 1
        return [[e00, e01, e02, 0],
                [e10, e11, e12, 0],
                [e20, e21, e22, 0],
                [0,   0,   0,   1]]

    def get_transform_matrix(self, obj):
        t = self.get_translation_matrix(obj["location"])
        r = self.get_rotation_matrix(obj["rotation"])
        s = self.get_scale_matrix(obj["scale"])
        return np.matmul(np.matmul(t, r), s)

    def get_vertex(self, obj, i):
        v = obj["vertices"][i]
        transformed = obj["location"] != [0, 0, 0] or obj["scale"] != [1, 1, 1] or obj["rotation"] != [1, 0, 0, 0]
        if transformed:
            matrix = self.get_transform_matrix(obj)
            v2 = [v[0], v[1], v[2], 1]
            transf = np.dot(matrix, v2)
            return tuple(transf[:3])
        else:
            return v

    def get_polygons_num(self, obj):
        return len(obj["indices"]) // 3

    def get_polygon(self, obj, i):
        return obj["indices"][(i * 3) : ((i + 1) * 3)]

    def get_position(self, obj):
        return obj["location"]

    def get_scale(self, obj):
        return obj["scale"]

    def create_composed_mesh(self):
        return self.create_obj()

    def create_and_add_composed_mesh_from_object(self, obj, new_block):
        new_obj = self.create_obj()
        new_obj["indices"] = obj["indices"].copy()
        new_obj["vertices"] = [self.get_vertex(obj, i) for i in range(len(obj["vertices"]))]
        nv = len(new_block["vertices"])
        new_block["vertices"] = new_block["vertices"] + new_obj["vertices"]
        new_block["indices"] = new_block["indices"] + [nv + e for e in new_obj["indices"]]
        return new_obj

    def destroy_composed_mesh(self, mesh):
        pass

    def find_vertex_in_list(self, v1, new_verts, epsilon):
        for i in range(len(new_verts)):
            v2 = new_verts[i]
            if np.linalg.norm(np.subtract(v1, v2)) < epsilon: return i
        return -1

    def remove_doubles(self, new_block, epsilon):
        new_verts = []
        indices_map = {}
        for i in range(len(new_block["vertices"])):
            v = new_block["vertices"][i]
            found_index = self.find_vertex_in_list(v, new_verts, epsilon)
            if found_index >= 0:
                indices_map[i] = found_index
            else:
                new_verts.append(v)
                indices_map[i] = len(new_verts) - 1
        new_indices = []
        for i in range(0, len(new_block["indices"]), 3):
            i0 = indices_map[new_block["indices"][i]]
            i1 = indices_map[new_block["indices"][i + 1]]
            i2 = indices_map[new_block["indices"][i + 2]]
            invalid = i0 == i1 or i1 == i2 or i2 == i0
            if not invalid:
                new_indices.append(i0)
                new_indices.append(i1)
                new_indices.append(i2)
        new_block["vertices"] = new_verts
        new_block["indices"] = new_indices
